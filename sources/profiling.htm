<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Cage Profiling Client</title>
		<script src="https://d3js.org/d3.v7.min.js"></script>
		<style>
			#status {
				float: left;
			}

			#menu {
				float: right;
			}

			#header hr {
				clear: both;
			}

			#tasks .threadName {
				text-align: center;
				padding: 0px;
				margin-top: 5px;
				margin-bottom: 1px;
			}

			#tasks .item {
				border: 1px solid red;
			}

			#tasks .item rect {
				width: 100%;
				height: 100%;
			}

			#tasks .item:hover rect {
				opacity: 40%;
			}

			#tasks .item text {
				text-anchor: middle;
				dominant-baseline: middle;
			}
		</style>
	</head>
	<body>
		<div id="header">
			<span id="status"></span>
			<span id="menu">
				<button id="pauseButton">Pause</button>
			</span>
			<hr>
		</div>
		<div id="frames"></div>
		<div id="tasks"></div>
		<script>
			const data = { threads: [], frames: [] }
			const colors = {}
			const zoom = d3.zoom()
			let zoomTrans = null
			let paused = false
			let uniqueCounter = 1

			d3.select("#pauseButton").on("click", d => paused = !paused )

			function mergeData(data, incoming) {
				incoming.threads.pop()
				incoming.threads.forEach(function (thr) {
					let i = data.threads.findIndex(t => t.name == thr.name)
					if (i == -1) {
						data.threads.push({
							name: thr.name,
							data: [],
							stor: {}
						})
						i = data.threads.length - 1
					}
					const dst = data.threads[i]
					thr.events.pop()
					thr.events.forEach(function (d) {
						let t = {}
						t.name = incoming.names[d[0]]
						t.category = incoming.names[d[1]]
						t.startTime = d[2]
						t.endTime = d[2] + d[3]
						dst.data.push(t)
						if (d[4]) {
							const fn = t.category + " / " + t.name
							let j = data.frames.findIndex(t => t.name == fn)
							if (j == -1) {
								data.frames.push({
									name: fn,
									data: []
								})
								j = data.frames.length - 1
							}
							const dstf = data.frames[j]
							dstf.data.push(t)
						}
					})
				})
			}

			function clearOldData(data) {
				data.endTime = d3.max(data.threads, thr => d3.max(thr.data, d => d.endTime))
				data.startTime = data.endTime - 100000;
				data.threads.forEach(function (thr) {
					thr.data = thr.data.filter(d => d.endTime > data.startTime)
				})
				data.frames.forEach(function (frm) {
					frm.data = frm.data.filter(d => d.endTime > data.startTime)
				})
			}

			function assignColors(data) {
				let regenerate = false
				data.threads.forEach(function (thr) {
					thr.data.forEach(function (d) {
						const k = d.name + "/" + d.category
						if (typeof colors[k] === "undefined") {
							colors[k] = null
							regenerate = true
						}
						else
							d.color = colors[k]
					})
				})
				if (regenerate) {
					const step = 1.0 / Object.keys(colors).length
					Object.keys(colors).forEach(function(key, index) {
						colors[key] = d3.interpolateSinebow(index * step)
					})
					assignColors(data, colors)
				}
			}
			
			function makeHierarchy(data) {
				data.forEach(function (a) {
					a.parent = null
					data.forEach(function (b) {
						if (b.startTime < a.startTime && b.endTime > a.startTime) {
							if (!a.parent || b.startTime > a.parent.startTime)
								a.parent = b
						}
					})
					a.children = []
				})
				data.forEach(function (a) {
					if (a.parent)
						a.parent.children.push(a)
					a.depth = 0
					let b = a
					while (b.parent) {
						a.depth++
						b = b.parent
					}
				})
				data.depth = d3.max(data, d => d.depth) || 0
			}

			function redraw(thr, stor) {
				function resetAxes() {
					stor.x.domain([data.startTime, data.endTime]).range([0, stor.width].map(d => (zoomTrans ? zoomTrans.applyX(d) : d)))
					stor.y.domain([-1, thr.data.depth]).range([0, stor.height])
					stor.axis.call(d3.axisBottom().scale(stor.x))
				}

				function positions(selection) {
					selection
						.attr("x", d => stor.x(d.startTime))
						.attr("y", d => stor.y(d.depth))
						.attr("width", d => stor.x(d.endTime) - stor.x(d.startTime))
						.attr("height", d => stor.y(d.depth + 1) - stor.y(d.depth))
				}

				function zoomed(event) {
					zoomTrans = event.transform
					resetAxes()
					stor.items.call(positions)
				}

				if (typeof stor["div"] === "undefined") {
					stor.div = d3.select("#tasks").append("div")
					stor.p = stor.div.append("p").classed("threadName", true).text(thr.name)
					stor.svg = stor.div.append("svg").attr("width", "100%")
					stor.x = d3.scaleLinear()
					stor.y = d3.scaleLinear()
					stor.itemsGroup = stor.svg.append("g").classed("items", true)
					stor.axis = stor.svg.append("g").classed("axis", true)
					stor.svg.call(zoom.on("zoom." + (uniqueCounter++), zoomed))
				}

				makeHierarchy(thr.data)
				stor.width = d3.select("body").node().getBoundingClientRect().width
				stor.height = (thr.data.depth + 1) * 20
				stor.svg.attr("height", stor.height)
				resetAxes()

				stor.items = stor.itemsGroup
					.selectAll(".item")
					.data(thr.data, d => d.startTime)
					.join("svg")
					.classed("item", true)
					.call(positions)
				stor.items
					.append("rect")
					.attr("fill", d => d.color)
				stor.items
					.append("text")
					.attr("x", "50%")
					.attr("y", "50%")
					.text(d => d.category + " / " + d.name)
				stor.items
					.append("title")
					.text(d => d.category + "\n" + d.name + "\n" + (d.endTime - d.startTime) + " us")

				stor.svg.node()
			}

			function update(incoming) {
				if (paused)
					return
				mergeData(data, incoming)
				clearOldData(data)
				assignColors(data)
				data.threads.forEach(function (thr) {
					redraw(thr, thr.stor)
				})
			}

			const ws = new WebSocket("ws://localhost:" + (new URLSearchParams(window.location.search)).get("port"))
			ws.addEventListener("open", event => {
				d3.select("#status").text("connected")
				console.log("connected")
			})
			ws.addEventListener("close", event => {
				d3.select("#status").text("disconnected")
				console.log("disconnected")
			})
			ws.onmessage = function(message) {
				let reader = new FileReader()
				reader.onload = () => {
					if (reader.result) {
						const incoming = JSON.parse(reader.result)
						update(incoming)
					}
				}
				reader.readAsText(message.data)
			}
		</script>
	</body>
</html>
